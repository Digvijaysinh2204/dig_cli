import 'dart:io';
import 'package:args/command_runner.dart';
import 'package:yaml/yaml.dart';

/// Command to generate asset constants from dig.yaml
class AssetCommand extends Command {
  @override
  final name = 'asset';

  @override
  final description = 'Generate asset constants from dig.yaml configuration';

  AssetCommand() {
    addSubcommand(_AssetBuildCommand());
    addSubcommand(_AssetWatchCommand());
  }
}

class _AssetBuildCommand extends Command {
  @override
  final name = 'build';

  @override
  final description = 'Generate asset constants once';

  @override
  Future<void> run() async {
    await _buildAssets();
  }
}

class _AssetWatchCommand extends Command {
  @override
  final name = 'watch';

  @override
  final description = 'Watch and auto-generate asset constants on changes';

  @override
  Future<void> run() async {
    await _watchAssets();
  }
}

Future<void> _buildAssets() async {
  print('üé® Generating asset constants...\n');

  // Read configuration from dig.yaml
  final configFile = File('dig.yaml');
  if (!configFile.existsSync()) {
    print('‚ùå dig.yaml not found!');
    print('üí° Create dig.yaml file with configuration:');
    print('''
assets-dir: assets/
output-dir: lib/gen
''');
    exit(1);
  }

  final configContent = configFile.readAsStringSync();
  final config = loadYaml(configContent);

  final assetsDir = Directory(config['assets-dir'] as String? ?? 'assets/');
  if (!assetsDir.existsSync()) {
    print('‚ùå Assets directory not found: ${assetsDir.path}');
    exit(1);
  }

  final outputDir = config['output-dir'] as String? ?? 'lib/gen';

  // Get skip/exclude patterns from config
  final skipPatterns = <String>[];
  if (config['skip'] != null) {
    final skipConfig = config['skip'];
    if (skipConfig is List) {
      skipPatterns.addAll(skipConfig.map((e) => e.toString()));
    } else if (skipConfig is String) {
      skipPatterns.add(skipConfig);
    }
  }

  // Scan assets and organize by category and type
  final assets = _scanAssets(assetsDir, skipPatterns);

  // Generate all files
  final generatedFiles = _generateMultipleFiles(assets, outputDir);

  // Print summary
  print('‚úÖ Generated ${_countTotalAssets(assets)} asset constants\n');
  print('üìÅ Generated Files:');
  for (final file in generatedFiles) {
    print('  $file');
  }
  print('');
}

Future<void> _watchAssets() async {
  print('üëÄ Watching assets directory for changes...\n');

  final assetsDir = Directory('assets');
  if (!assetsDir.existsSync()) {
    print('‚ùå Assets directory not found!');
    exit(1);
  }

  // Generate once on start
  await _buildAssets();

  // Watch for changes
  assetsDir.watch(recursive: true).listen((event) {
    final path = event.path;
    if (path.endsWith('.svg') ||
        path.endsWith('.png') ||
        path.endsWith('.jpg') ||
        path.endsWith('.jpeg') ||
        path.endsWith('.ttf') ||
        path.endsWith('.otf') ||
        path.endsWith('.webp') ||
        path.endsWith('.gif')) {
      print('\nüìÅ Detected change: ${path.split(Platform.pathSeparator).last}');
      _buildAssets();
    }
  });

  print('\nüîÑ Watching for changes... (Press Ctrl+C to stop)');

  // Keep the process running
  await ProcessSignal.sigint.watch().first;
  print('\nüëã Stopped watching');
}

/// Scan assets and organize by subfolder and file type
/// Returns: {
///   'bottom_bar': {
///     'png': [AssetInfo...],
///     'svg': [AssetInfo...],
///   },
///   'top_bar': {
///     'svg': [AssetInfo...],
///   },
///   'fonts': {
///     'ttf': [AssetInfo...],
///   }
/// }
Map<String, Map<String, List<_AssetInfo>>> _scanAssets(
    Directory dir, List<String> skipPatterns) {
  final assets = <String, Map<String, List<_AssetInfo>>>{};

  final allFiles = dir.listSync(recursive: true);

  for (final entity in allFiles) {
    if (entity is File) {
      final path = entity.path.replaceAll('\\', '/');
      final extension = path.split('.').last.toLowerCase();
      final relativePath = path.substring(path.indexOf('assets/'));

      // Check if this path should be skipped
      if (_shouldSkip(relativePath, skipPatterns)) {
        continue;
      }

      // Extract subfolder name from path
      // Example: assets/bottom_bar/svg/icon.svg ‚Üí bottom_bar
      // Example: assets/icons/home/svg/icon.svg ‚Üí icons/home
      final pathParts = relativePath.split('/');
      if (pathParts.length < 3) continue; // Need at least assets/folder/file

      // Get all folder parts between 'assets' and the file
      var subfolders = pathParts.sublist(1, pathParts.length - 1);

      // Join subfolders with underscore for nested paths
      // assets/icons/home/icon.svg ‚Üí icons_home
      final category = subfolders.join('_');

      // Determine file type
      String? fileType;
      if (extension == 'png' ||
          extension == 'jpg' ||
          extension == 'jpeg' ||
          extension == 'svg' ||
          extension == 'webp' ||
          extension == 'gif') {
        fileType = extension == 'jpeg' ? 'jpg' : extension;
      } else if (extension == 'ttf' || extension == 'otf') {
        fileType = extension;
      }

      if (fileType != null) {
        // Initialize category and file type if they don't exist
        assets.putIfAbsent(category, () => {});
        assets[category]!.putIfAbsent(fileType, () => []);

        final fileName = path.split('/').last.split('.').first;
        final constantName = _toConstantName(fileName);
        assets[category]![fileType]!
            .add(_AssetInfo(constantName, relativePath));
      }
    }
  }

  return assets;
}

String _toConstantName(String fileName) {
  // Convert any file name format to proper camelCase
  // Examples:
  // - ic_back.svg -> icBack
  // - my_icon.svg -> myIcon
  // - some-icon.svg -> someIcon
  // - SOmeIcon.svg -> someIcon
  // - MyIcon.svg -> myIcon

  // Replace hyphens with underscores for consistency
  var normalized = fileName.replaceAll('-', '_');

  // Split by underscore
  var parts = normalized.split('_').where((p) => p.isNotEmpty).toList();

  if (parts.isEmpty) return fileName.toLowerCase();

  // If no underscores/hyphens, check for camelCase or PascalCase
  if (parts.length == 1) {
    final part = parts.first;
    // Convert to proper camelCase (first letter lowercase, rest as-is for readability)
    return part[0].toLowerCase() + part.substring(1);
  }

  // First part lowercase, rest capitalized properly
  final first = parts.first.toLowerCase();
  final rest = parts
      .skip(1)
      .map((p) => p[0].toUpperCase() + p.substring(1).toLowerCase());

  return first + rest.join('');
}

/// Generate multiple files organized by category and type
/// Returns list of generated file paths
List<String> _generateMultipleFiles(
    Map<String, Map<String, List<_AssetInfo>>> assets, String outputDir) {
  final generatedFiles = <String>[];

  // Create output directory
  final baseDir = Directory(outputDir);
  if (!baseDir.existsSync()) {
    baseDir.createSync(recursive: true);
  }

  final categoryExports = <String>[];

  // Generate files for each category
  for (final categoryEntry in assets.entries) {
    final category = categoryEntry.key;
    final typeMap = categoryEntry.value;

    if (typeMap.isEmpty) continue;

    final typeExports = <String>[];

    // Generate type-specific files (e.g., icons_png.dart, icons_svg.dart)
    for (final typeEntry in typeMap.entries) {
      final fileType = typeEntry.key;
      final assetList = typeEntry.value;

      if (assetList.isEmpty) continue;

      final className = _toCategoryClassName(category, fileType);
      final fileName = '${category}_$fileType.dart';
      final filePath = '$outputDir/assets/$category/$fileName';

      final typeFileContent =
          _generateTypeFile(className, assetList, category, fileType);

      final typeFile = File(filePath);
      typeFile.createSync(recursive: true);
      typeFile.writeAsStringSync(typeFileContent);

      generatedFiles.add(filePath);
      typeExports.add("export '$category/$fileName';");
    }

    // Generate category export file (e.g., icons.dart)
    if (typeExports.isNotEmpty) {
      final categoryFilePath = '$outputDir/assets/$category.dart';
      final categoryFileContent = _generateCategoryFile(typeExports);

      final categoryFile = File(categoryFilePath);
      categoryFile.createSync(recursive: true);
      categoryFile.writeAsStringSync(categoryFileContent);

      generatedFiles.add(categoryFilePath);
      categoryExports.add("export 'assets/$category.dart';");
    }
  }

  // Generate main export file (assets.dart)
  if (categoryExports.isNotEmpty) {
    final mainFilePath = '$outputDir/assets.dart';
    final mainFileContent = _generateMainFile(categoryExports);

    final mainFile = File(mainFilePath);
    mainFile.writeAsStringSync(mainFileContent);

    generatedFiles.insert(0, mainFilePath);
  }

  return generatedFiles;
}

String _toCategoryClassName(String category, String fileType) {
  // bottom_bar + svg ‚Üí BottomBarSvg
  // top_bar + png ‚Üí TopBarPng
  // icons_home + svg ‚Üí IconsHomeSvg

  // Split category by underscore and capitalize each part
  final categoryParts = category.split('_');
  final categoryCapitalized = categoryParts
      .map((part) => part[0].toUpperCase() + part.substring(1))
      .join('');

  final typeCapitalized = fileType[0].toUpperCase() + fileType.substring(1);
  return '$categoryCapitalized$typeCapitalized';
}

String _generateTypeFile(String className, List<_AssetInfo> assets,
    String category, String fileType) {
  final buffer = StringBuffer();

  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// Generated by: dg asset build');
  buffer.writeln();
  buffer.writeln('// ignore_for_file: type=lint');
  buffer.writeln();
  buffer.writeln('/// ${fileType.toUpperCase()} $category assets');
  buffer.writeln('class $className {');
  buffer.writeln('  const $className._();');
  buffer.writeln();

  assets.sort((a, b) => a.name.compareTo(b.name));

  for (final asset in assets) {
    buffer.writeln('  /// ${asset.path}');
    buffer.writeln("  static const String ${asset.name} = '${asset.path}';");
    if (asset != assets.last) buffer.writeln();
  }

  buffer.writeln('}');
  buffer.writeln();

  return buffer.toString();
}

String _generateCategoryFile(List<String> exports) {
  final buffer = StringBuffer();

  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// Generated by: dg asset build');
  buffer.writeln();
  buffer.writeln('// ignore_for_file: type=lint');
  buffer.writeln();

  for (final export in exports) {
    buffer.writeln(export);
  }

  return buffer.toString();
}

String _generateMainFile(List<String> categoryExports) {
  final buffer = StringBuffer();

  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
  buffer.writeln('// Generated by: dg asset build');
  buffer.writeln('// Configuration: dig.yaml');
  buffer.writeln();
  buffer.writeln('// ignore_for_file: type=lint');
  buffer.writeln();
  buffer.writeln('/// Asset constants generated from your assets directory.');
  buffer.writeln('///');
  buffer.writeln('/// To use these assets in your application:');
  buffer.writeln('///');
  buffer.writeln('/// ```dart');
  buffer.writeln("/// import 'package:flutter_svg/flutter_svg.dart';");
  buffer.writeln("/// import 'package:your_app/gen/assets.dart';");
  buffer.writeln('///');
  buffer.writeln('/// // For SVG icons');
  buffer.writeln('/// SvgPicture.asset(IconsSvg.icBack);');
  buffer.writeln('///');
  buffer.writeln('/// // For PNG images');
  buffer.writeln('/// Image.asset(ImagesPng.logo);');
  buffer.writeln('///');
  buffer.writeln('/// // For fonts');
  buffer.writeln("/// TextStyle(fontFamily: FontsTtf.regular);");
  buffer.writeln('/// ```');
  buffer.writeln('///');
  buffer.writeln('/// ## Regenerating Assets');
  buffer.writeln('///');
  buffer.writeln('/// To regenerate this file after adding/removing assets:');
  buffer.writeln('///');
  buffer.writeln('/// ```bash');
  buffer.writeln('/// dg asset build');
  buffer.writeln('/// ```');
  buffer.writeln('///');
  buffer.writeln('/// Or use watch mode for automatic regeneration:');
  buffer.writeln('///');
  buffer.writeln('/// ```bash');
  buffer.writeln('/// dg asset watch');
  buffer.writeln('/// ```');
  buffer.writeln('///');
  buffer.writeln('/// ‚ö†Ô∏è **WARNING**: Do not modify this file manually.');
  buffer.writeln('/// All changes will be overwritten on next generation.');
  buffer.writeln();

  for (final export in categoryExports) {
    buffer.writeln(export);
  }

  return buffer.toString();
}

int _countTotalAssets(Map<String, Map<String, List<_AssetInfo>>> assets) {
  var count = 0;
  for (final typeMap in assets.values) {
    for (final assetList in typeMap.values) {
      count += assetList.length;
    }
  }
  return count;
}

/// Check if a path should be skipped based on skip patterns
bool _shouldSkip(String path, List<String> skipPatterns) {
  for (final pattern in skipPatterns) {
    // Normalize pattern
    final normalizedPattern = pattern.replaceAll('\\', '/');

    // Check if path matches the pattern
    // Examples:
    // - 'icons' matches 'assets/icons/...'
    // - 'icons/svg' matches 'assets/icons/svg/...'
    // - 'fonts' matches 'assets/fonts/...'
    if (path.contains('/$normalizedPattern/') ||
        path.startsWith('assets/$normalizedPattern/')) {
      return true;
    }
  }
  return false;
}

class _AssetInfo {
  final String name;
  final String path;

  _AssetInfo(this.name, this.path);
}
